<!DOCTYPE html>
<html>
<head>
  <style type="text/css">
  .bgimg {
    background-image: url('./res/bg.jpg');
    background-repeat:no-repeat;
    background-size:100%;
    width: 100%;
    padding-bottom: 44.5%;
  }
  body {
    margin: 10em;
  }

  p{
    word-wrap: break-word;
  }

  avatar {
    width:100;
    height:100;
  }
  h1 {text-align:center;}
  h2 {text-align:center;}
  h3 {text-align:center;}
  h4 {text-align:center;}
  textarea {resize: none;}
  </style>
  <meta charset="utf-8"/>
  <link rel="icon" href="res/favicon.ico" type="image/x-icon" />
  <link rel="shortcut icon" href="res/favicon.ico" type="image/x-icon" />
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css">
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script>
</header>

<body>

  <div class="well" style="background-color:rgb(35, 35, 35); color: white">
    <h1>Symmetric 'Guess Who?'</h1>
    <h3>Danny Rogaar<br>Jan Willem de Wit<br>Herman Groenbroek</h3>
  </div>

  <div class="container">
    <div class="col-md-8 col-md-offset-2">
      <h2>The Game</h2>

      <p>In the game of <i>Guess Who?</i>, two opposing players pick an avatar from a given set of characters. The characters that players can choose have various
        attributes such as their hair colour, or whether they are wearing glasses. It is up to the players to guess what character their opponent has chosen in order to win the game. Players may ask binary questions about the attributes in order to gain
        information on which avatar the opponent has chosen.</p>

        <p> The variant that is analysed here is a symmetric <i>Guess Who?</i>. Here, once a player asks a question about an attribute, both players have to say whether or not their character satisfies the mentioned attribute, truthfully. The implications of the symmetric gameplay is that players may be unable to ask direct questions when it would reveal which character they are playing themselves. Thus, as a player, you need to have information on what your opponent knows about your character.
        </p>


      </div>
    </div>

    <!-- THE INTERACTIVE GAME -->
    <br><br>
    <div class="container">
      <div class="row">
        <div class="bgimg col-sm-8 h-100" id="arena">
          <div class="row" style="position:absolute; left: 36%; top:10%;">
            <img class="avatar col-xs-2" id="p0_char4" src="./res/chars/hg t1 cn.png" height="60">
            <div class="col-xs-1"></div>
            <img class="avatar col-xs-2" id="p0_char1" src="./res/chars/hg t1 cn.png" height="60">
            <div class="col-xs-1"></div>
            <img class="avatar col-xs-2" id="p0_char2" src="./res/chars/hg t1 cn.png" height="60">
            <div class="col-xs-1"></div>
            <img class="avatar col-xs-2" id="p0_char3" src="./res/chars/hg t1 cn.png" height="60">
          </div><div class="row" style="position:absolute; left: 36%; top:25%;">
            <img class="avatar col-xs-2" id="p0_char5" src="./res/chars/hg t1 cn.png" height="60">
            <div class="col-xs-1"></div>
            <img class="avatar col-xs-2" id="p0_char6" src="./res/chars/hg t1 cn.png" height="60">
            <div class="col-xs-1"></div>
            <img class="avatar col-xs-2" id="p0_char7" src="./res/chars/hg t1 cn.png" height="60">
            <div class="col-xs-1"></div>
            <img class="avatar col-xs-2" id="p0_char8" src="./res/chars/hg t1 cn.png" height="60">
          </div>

          <div class="row"><br></div>

          <div class="row" style="position:absolute; left: 36%; top:60%;">
            <img class="avatar col-xs-2" id="p1_char4" src="./res/chars/hg t1 cn.png" height="60">
            <div class="col-xs-1"></div>
            <img class="avatar col-xs-2" id="p1_char1" src="./res/chars/hg t1 cn.png" height="60">
            <div class="col-xs-1"></div>
            <img class="avatar col-xs-2" id="p1_char2" src="./res/chars/hg t1 cn.png" height="60">
            <div class="col-xs-1"></div>
            <img class="avatar col-xs-2" id="p1_char3" src="./res/chars/hg t1 cn.png" height="60">
          </div><div class="row" style="position:absolute; left: 36%; top:75%;">
            <img class="avatar col-xs-2" id="p1_char5" src="./res/chars/hg t1 cn.png" height="60">
            <div class="col-xs-1"></div>
            <img class="avatar col-xs-2" id="p1_char6" src="./res/chars/hg t1 cn.png" height="60">
            <div class="col-xs-1"></div>
            <img class="avatar col-xs-2" id="p1_char7" src="./res/chars/hg t1 cn.png" height="60">
            <div class="col-xs-1"></div>
            <img class="avatar col-xs-2" id="p1_char8" src="./res/chars/hg t1 cn.png" height="60">
          </div>
        </div>
        <div class="col-sm-1" id="empty_width"></div>
        <div class="col-sm-3" id="consoleArea">
          <div class="form-group">
            <div class="radio">
              <label class="radio"><input type="radio" name="consoleType" onchange="consoleChange()" id="QnA" checked="checked">Q & A</label>
              <label class="radio"><input type="radio" name="consoleType" onchange="consoleChange()" id="commonKnowledge">Common Knowledge</label>
              <label class="radio"><input type="radio" name="consoleType" onchange="consoleChange()" id="agentKnowledge">Agent Knowledge</label>
            </div>
            <textarea class="form-control rounded-0" id="console" rows="23" cols="25" disabled></textarea>
          </div>
        </div>
      </div>
    </div>
    <br>
    <div class="row" style="text-align: center">
      <button type="button" class="btn btn-default" id="stepButton" onclick="stepGame()">Next step</button>
      <button type="button" class="btn btn-default" id="resetButton" onclick="resetGame()">Reset game</button>
      <button type="button" class="btn btn-info" id="helpButton" onclick="help()">Help me</button>
    </div>
  </div>

  <script src="character.js"></script>
  <script src="player.js"></script>
  <script src="knowledge.js"></script>
  <script src="images.js"></script>
  <script src="main.js"></script>

  <div class="container">
    <div class="col-md-8 col-md-offset-2">
      <h2>Using epistemic logic</h2>

      <p>
        The game is analysed here using epistemic logic. We use the knowledge
        operator K to represent what knowledge is held by each player. A Kripke model in S5 is shown below. Each world consists of a pair of characters such that each player has chosen a character. Since each player knows what character they have, they know which characters they do not have. Therefore, e.g. player 1 can only access worlds where the character for player 1 is the same as the one he chose. This means that worlds have connections to each other world where the local state is preserved, much like the distributed systems used in chapt. 1.8, "Epistemic Logic for AI and Computer Science" by Meyer and van der Hoek (1995).
      </p>

      <img id="model"  style="display: block; width:600px; height:450px; margin: 0 auto;" src="./res/kripkemodel.jpg">

      <p>
        The system shown above uses double lines to indicate that every state along that line can be reached from any other state reached. Notably, states along these lines can make 'jumps' to another state along the same line. Given that players know which attributes their character has, players may only access states in which this chosen character is the same. Thus, there is a horizontal and vertical double line for player one and two respectively, in order to access the reachable states.
        <br><br>
        We have indicated the propositions that are true in a world by showing the avatar for each player. The avatars, here, form a specification on propositions that are true and false by visualising the attributes of the characters, such as red hair and having two teeth. Then, the visualisation marks whether a given proposition is true or false. We use propositions for the attributes hair (red, green or blue), teeth (characters have either 0, 1 or 2 teeth) crosseyed (characters either have normal centred eyes or not) and character name. A proposition is displayed in the consoles as for example: p1.hair:red, which would indicate that player 1's character has red hair. All character names are listed in the help section.
        <br><br>
        Given that players have access to the local states in the above Kripke model, indeed, players have knowledge about the avatar that they have themselves. However, relations for a local state exists to all of the worlds that have varying avatars for the opponent. So, players do not know which avatar their opponent has until they have asked questions.
      </p>

      <h2> Announcement logic</h2>
      <p>
        So, what happens when a player asks a question? That is, a player makes a statement that from that moment on, should be true. To account for this, announcement logic is used. This logic introduces restrictions on the Kripke model such that any (always truthful) answer players give to a question will be true in the Kripke model. For example, when a players asks whether an avatars hair is red and both players answer no, the Kripke model is restricted to only the worlds where both player's avatar is not red. Any relations agents have to the worlds with red hair are also not considered. Using this logic, a game of Guess Who? becomes a series of restrictions on the Kripke model until a player has access to only one world and thereby knows his opponent's avatar. An example of a model restriction following a question is shown below.
      </p>

      <img id="model"  style="display: block; width:723px; height:441px; margin: 0 auto;" src="./res/restrictedmodel.jpg">

      <h2> Asking questions</h2>
      <p> Given the logic and Kripke model, then, what is the best question an agent can ask? We find that new questions can decrease the number of avatars an opponent could possibly have. For a player, a question is intended to gain the most information about his opponent's avatar while giving away the least amount of information about his own avatar. We implement this strategy by counting the possible world in the restricted Kripke model, following the question that have been asked. That is, the most informative question about the opponent is the one that has the largest reduction in possible avatars of the opponent after restricting the model to the given question. Similarly, the safest question for you has the smallest reduction in worlds that you believe the opponent holds possible for you.

        <h2> Simulating many games </h2>
        If we run a number of <i>Guess Who?</i> games, we can get results on the strategies for a player. Below, you can press the 'simulate n games' button to see the resulting score for each player. To show the effect of strategy, we have one player asking random questions about avatars, and the other agent using the strategy described earlier.
        <p>
          <div class="input-group">
            <div class="input-group-btn">
              <button class="btn btn-default" onclick="playManyGames() ">Simulate n games</button>
            </div>
            <input type="text" id="nGames" class="form-control" placeholder="20" size="1" />
            <span class="input-group-btn" style="width:0px;"></span>
            <input type="text" id="simulationOutput" class="form-control" value="no output yet" disabled/>
          </div>
        </p>

        <br>
        <h1 id="help">Need help?</h1>

        <p>
          At the top of the page you will find the interactive game of <i>Guess Who</i>. By pressing 'next step', the game advances by one step, i.e. one player asks a question and each players answers this question with regard to their chosen avatar. Both players' knowledge about their opponent's avatar will be updated, and the knowledge base tries to prove new propositions using the rules of the game. Note that pressing 'reset game' will reset all knowledge and chosen avatars. Pressing 'help me' should bring you to this section.
        </p>

        <p>
          The demo shows player 1 first and player 2 below that. The character that is circled is the character of the opponent that this player has to guess. The characters shown are the possibilities left for the opponent's character with the current knowledge. 
        </p>

        <br>
        <img id="model" style="display: block; width:600px; height:auto; margin: 0 auto;" src="./res/charNames.png">
        <br>

        <p>
          Meet the characters -- the image above tells you who's who, in case you couldn't tell from the character attributes in the interactive game.
        </p>
        <br><br>

        <h1>Project implementation</h1>
        <p>
          We implemented the game in javascript. We create two players that both select a random character. We use a knowledge class to represent all the knowledge about the characters. This knowledge base contains rules that are known beforehand to the player, for instance that if a character does not have red or green hair, it must have blue hair. It also contains information about which of the characters has which attributes, for example: red hair, crosseyed and 0 teeth imply that the character is peter. In each game step, one of the players can ask a question. This can be done randomly, but we also implemented a strategy that selects a question in a smart way. 

          <br><br>

          When asking a question, a player has to take into account that they have to answer their own question as well. Because of this, they need to ask a question that does not reveal their own character. At the same time, the question should not be too specific. For example, there could be only one character left that has green hair but many others that do not. If you ask if the opponent's character has green hair and you get lucky, the answer is yes and you now know the answer; but most likely, this will not be the case and you can only cross out one character. Therefore, it is better to ask questions where you can cross out many characters regardless of the answer. It is best to ask the question where half of the characters can be crossed out if the answer is yes, and the other half if the answer is no. To implement this, we let the agent reason about each of the possible questions and calculate a score based on this. The formula for this score is the following:


          <br><br>

          Score_q = <b>A</b> - abs(<b>B</b> - <b>C</b>)
          <br>
          where <br>
          <b>A</b> = possible characters left for player after asking question q <br>
          <b>B</b> = possible characters left for opponent if answer of opponent is “yes” <br>
          <b>C</b> = possible characters left for opponent if answer of opponent is “no” <br><br>

          The more characters that are left for the player after asking this question, the higher the score. The smaller the difference between possible characters between the answers (yes or no), the higher the score. The player ends up asking the question with the highest score.

          <br><br>

          When a question is asked, both players answer the question and the new knowledge is added to the knowledge base. We implemented our own logic prover that now tries to infer additional facts based on the old knowledge and the newly added information. For example, if we already knew that the hair of the character was not blue and we now have the new information that the hair is also not red, our logic prover will use one of the rules to infer that the hair must be blue. INSERT MORE EXPLANATION ABOUT SOLVER HERE. This continues until one or both of the players knows which character the opponent had chosen. 
        </div>
      </div>
  </body>
  </html>
